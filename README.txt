Project Overview

The purpose of this project is to create an interactive mathematical calculation game in which the user must insert the appropriate operators (addition, subtraction, multiplication, division) between a set of random numbers to form a valid equation. The player can choose the range and number of random numbers himself, and then the system will automatically generate the random numbers and check the validity of the resulting equations, as required. The goal is to ensure that the generated numbers and operators always produce solvable mathematical equations. The player has three chances to enter the equation, and if all three times are wrong, the system will ask the player if they want to know the correct answer. Of course, we also added a play again function, where the player can continue to produce new questions after answering correctly.

Time Spent on the Project:
We typically spent about 2 hours a week on this project, mainly because each revision revealed new bugs that needed to be fixed. Additionally, we frequently made adjustments to the game mechanics to keep it engaging and provide the player with more freedom. Over the course of several weeks, we continuously refined the code to ensure it aligned with the original proposal's goals and functioned without bugs.
Beyond addressing the core calculation logic, we also explored ways to enhance the overall gaming experience. For instance, we focused on clarifying the game rules to ensure players understood the rules clearly. We added customizable features that allowed players to set the range and number of random numbers, offering more interactivity and control. To raise the challenge and excitement, we introduced a limit of three attempts per round, adding a layer of tension and encouraging players to strategize more carefully with their equations. These iterative improvements not only made the game more dynamic but also balanced flexibility with difficulty, creating a more engaging experience for the player.
In the final version, we have made several improvements. First, we improved the parentheses recognition, so that now both system-generated correct answers and player-submitted equations handle parentheses correctly and accurately evaluate expressions with different operator precedence. We have added a new test for parentheses handling, test_parentheses_handling, which ensures that expressions with parentheses are parsed and computed correctly. This improvement not only improves the accuracy of the game, but also allows players to complete challenges with more complex calculations. 
Second, although we had envisioned adding new operators (such as squares, more signs, and logarithms) in our initial plans, we ultimately chose to abandon this plan due to time constraints and the complexity of making changes to the core code. Instead, we focused on optimizing the functionality of existing operators. 
Finally, we significantly improved our testing framework by adding more test scenarios to improve the robustness of the game. In addition, we refined the function of prompting the user after an input error, and verified the correctness of the player's processing logic after reaching the maximum number of attempts by testing, e.g., simulating such scenarios in test_provide_solution_after_max_attempts. The improved tests cover most of the functionality and boundary cases in the game to ensure the robustness of the code and the accuracy of the functionality.


Most Time-Consuming Part:
The most time-consuming part of the project was ensuring that the system generates correct and solvable mathematical equations automatically. Initially, the generated equations were not always correct due to improper operator handling, which required extensive testing and debugging. A significant portion of the time was spent on making sure the find_solution() function works correctly and consistently returns equations that are valid and can be solved by the player.
Another problem we encountered was that the player's input equation must use "==" for the equation to be considered valid. The code was designed to evaluate whether the left-hand side and the right-hand side of the equation have equal results. If the player doesn’t use "==" to separate the two sides, the program cannot properly compare them, leading to an invalid equation. Although we upgraded the system from seeing if the difference between the two sides of the equation was the same to seeing if the values on both sides of the equation were equal by changing the code, we still didn't solve the problem of the player needing to enter “==” in order for the system to recognize it as the equal sign of the equation.

How to be more efficient?
To work more efficiently while writing the program, it’s crucial to adopt a few key practices. First, implementing continuous testing throughout the development process is essential. By testing as you code, you can catch issues early and fix them incrementally, rather than waiting until the entire program is finished, which can make debugging much more difficult. Second, having a clear program flow and modular design is important. Breaking the program into smaller, independent modules ensures that if an error occurs, you can easily identify which part of the program is responsible. This also simplifies testing and debugging of individual sections. Finally, planning the features and functionality of the program at the beginning is critical. Instead of adding features as you go along, which can lead to major structural changes later, having a clear roadmap helps maintain focus and reduces the need for large-scale revisions down the line. This planning saves time and effort in the long run.

Useful starter code/libraries:
When we were searching for inspiration and guidance on how to build the code for our math game, we came across a shared project on GitHub that was incredibly helpful. This code, which was also for a math-based game, provided us with valuable insights into how to build the logical flow of the game, manage random number generation, and handle user input in an interactive environment. The GitHub project helped us to understand the fundamental structure we needed to create for our own game, including how to format equations, validate answers, and implement different mathematical operators. This starter code not only gave us a reference for some of the key functions, but it also helped us think through how to design our own game’s features and implement the underlying logic.
While we were inspired by the GitHub code, we did not simply copy it. Instead, we carefully analyzed its components and adjusted them to fit the specific needs and goals of our project. For example, we modified the way random numbers were generated and added features such as the ability for players to set the range and number of numbers used in the equation. Additionally, we integrated our own validation system that checks whether the player’s equation is solvable and correct. We also incorporated new game mechanics, like limiting the player to three attempts per round, which weren’t part of the original code.
In addition to using the starter code from GitHub, we leveraged ChatGPT to help us further refine and customize our code. ChatGPT was instrumental in improving the flow of the game logic and fixing bugs we encountered, especially in the equation validation process. It guided us through tricky parts of the project, such as ensuring that all generated equations are solvable and helping us handle user input errors. By combining the starter code with ChatGPT's insights, we were able to make the code much more robust and tailored to our game’s specific requirements.
Overall, while the GitHub code gave us a strong foundation to work from, we significantly modified and expanded it to suit our project's unique vision and to implement features that would make the game more interactive and challenging.

